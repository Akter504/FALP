#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Марьян А.О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения задач, связанных с переходом из начального состояния в конечное с использованием определенных действий, эффективно применять язык логического программирования, такой как Prolog. В отличие от императивных языков программирования, где необходимо явно указывать шаги для достижения желаемого результата, в Prolog достаточно описать, что именно пользователь хочет получить. Это особенно удобно в случаях, когда количество возможных состояний велико, и сложно явно прописать каждый возможный путь.

## Задание

Вариант №6
Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3
белых шара. Передвинуть черные шары на место белых, а белые - на
место черных. Шар можно передвинуть в соседнюю с ним пустую
лунку, либо в пустую лунку, находящуюся непосредственно за
ближайшим шаром. При этом черные шары можно передвигать
только вправо, а белые - только влево.

## Принцип решения

Предикат move, реализует сдвиг шаров. Создает два списка с начальным и конечным списком (всего 4 состояние относительно заданных условий).
```prolog
move(In,Out):-
	append(S,['_','w'|T],In),
	append(S,['w','_'|T],Out).
move(In,Out):-
	append(S,['b','_'|T],In),
	append(S,['_','b'|T],Out).
move(In,Out):-
	append(S,['_','b','w'|T],In),
	append(S,['w','b','_'|T],Out).
move(In,Out):-
	append(S,['b','w','_'|T],In),
	append(S,['_','w','b'|T],Out).

```
Предикат продления пути с предотвращением петель.
```prolog
prolong([X|T],[Y,X|T]):-
	move(X,Y),
	not(member(Y,[X|T])).
```
Предикат для поиска в глубину, для данной задачи
```prolog
dpth([X|T],X,[X|T]).
dpth(P,X,R):-
	prolong(P,O),
	dpth(O,X,R).
```
Нахождение всех нужных аргументов для заполнения таблицы + запуск поиска в глубину для решения задачи.
```prolog
dpth_search(In,Out):-
	get_time(TimeStart),
	dpth([In],Out,Sub),
	get_time(TimeEnd),
	Time is TimeEnd - TimeStart,
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```
Предикат для поиска в ширину, для данной задачи
```prolog
bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):-
	findall(W,prolong(P,W),T),
	append(QI,T,QO),!,
	bdth(QO,X,R).
bdth([_|T],Out,L):- bdth(T,Out,L).
```
Нахождение всех нужных аргументов для заполнения таблицы + запуск поиска в ширину для решения задачи.
```prolog
bdth_search(In,Out):-
	get_time(TimeStart),
	bdth([[In]],Out,Sub),
	get_time(TimeEnd),
	Time is TimeEnd - TimeStart,
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```
Предикат для генерации чисел (1, до +inf).
```prolog
int(1).
int(N):- int(M), N is M+1.
```
Предикат для поиска итерационным методом, для данной задачи
```prolog
iter([X|T],X,[X|T],0).
iter(P,X,R,N):-
	N>0, prolong(P,W),
	N1 is N-1,
	iter(W,X,R,N1).
```
Нахождение всех нужных аргументов для заполнения таблицы + запуск поиска итерационным методом для решения задачи.
```prolog
iter_search(In,Out):-
	get_time(TimeStart),
	int(Level),
	(Level>100,!;iter([In],Out,Sub,Level)),
	get_time(TimeEnd),
	Time is TimeEnd - TimeStart,
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```
Предикат для вывода списка.
```prolog
print([_]):-!.
print([B|T]):-
	print(T),nl,write(B).
```
Предикат для запуска задачи
```prolog
solve:-
	In = ['b', 'b', 'b', 'b', '_', 'w', 'w', 'w'],
	Out = ['w', 'w', 'w', '_', 'b', 'b', 'b', 'b'],
	writeln('Iterative'),
	iter_search(In, Out),

	writeln('DPTH'),
	dpth_search(In, Out),

	writeln('BDTH'),
	bdth_search(In,Out),
        !.
```

## Результаты

! Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------------------------------------------------------------------|
| В глубину       |                  20              |        0.00035190582275390625        |
| В ширину        |                  20              |        0.0019009113311767578        |
| ID              |                  20              |         0.009171009063720703        |
```prolog
?- solve.
Iterative

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.009171009063720703

BDTH

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.00035190582275390625

DPTH

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.0019009113311767578
```

## Выводы

Результаты проведенной лабораторной работы не позволяют легко выявить различия между методами поиска в глубину, в ширину и итеративным углублением (ID). Это обусловлено тем, что дерево решений задачи имеет одинаковую высоту в 20 уровней, что делает каждый путь от начального состояния к конечному состоянию состоящим из 20 шагов. Несмотря на это, анализ результатов и знание теоретических основ, полученных из лекций и внешних источников, позволяют выделить отличия между методами.

Очевидно, что поиск в глубину демонстрирует более эффективные результаты, поскольку ему не приходится исследовать боковые ветви дерева запросов. Это особенно актуально в случае, когда количество состояний значительно. Примечательно, что логический язык программирования, такой как Prolog, оказывается удобным инструментом для решения подобных задач, обеспечивая более лаконичные и понятные решения, чем императивные языки.




