# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Марьян А.О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Одно из основных свойств списка – отсутствие ограничений на элементы,размер списка,вложенность.В Прологе списки реализованы как рекурсивные структуры данных. Каждый список представляется в виде головы (первого элемента) и хвоста (оставшейся части списка), которая также является списком. От принятых в императивных языках подходов к хранению данных списки Пролога отличаются, в первую очередь, произвольным типом элементов, такое свободное отношение к типам редко в императивных языках. Списки Пролога очень похожи на бинарные деревья, с тем допущением, что каждый узел имеет лист.
## Задание 1.1: Предикат обработки списка

`func4_without_stdrd_prdt(List, Length, OutList)` - Усечение списка без стандартных предикатов.
`func4(List, Length, OutList)` - Усечение списка с стандартными предикатами.

Примеры использования:
```prolog
?- func4([1,2,3,4],2,OutList).
OutList = [1,2].
?- func4_without_stdrd_prdt([1,2,5,4,7,2],3,OutList).
OutList = [1,2,5].
```

Реализация:
Заполняем массив List1 элементом из "Головы" переданного списка, пока длина не нуль.
Без встроенных предикатов:
```prolog
func4_without_stdrd_prdt(_, 0, []).
func4_without_stdrd_prdt([X|Tail], Length, [X|List1]) :-
    Length > 0,
    NewLength is Length - 1,
    func4_without_stdrd_prdt(Tail, NewLength, List1).
```
С встроенными предикатами:
```prolog
func4(_,0,[]).
func4(Tail, Length, List1) :-
    length(List1, Length),
    append(List1, _, Tail).
```
Сначала определяем длину для List1, затем его заполняем.


## Задание 1.2: Предикат обработки числового списка

`max_f_without_stdrd_prdt(List, Max, Index)` - Максимальный элемент и индекс максимального элемента без стандартных предикатов.
`max_f(List, Max, Index)` - Максимальный элемент и индекс максимального элемента с стандартными предикатами.

Примеры использования:
```prolog
?- max_f([30,10,5,4,3,27], Max, Index).
Max = 30.
Index = 0.
?- max_f_without_stdrd_prdt([2,10,5,4,3,27], Max, Index).
Max = 27.
Index = 5.
```

Реализация:
Проходим рекурсивно по элементам массива сравнивая каждый элемент с TempMax, когда будет конец списка мы положим значение в TempMax и сможем наибольший результат положить в Max.
Без встроенных предикатов:
```prolog
max_f_without_stdrd_prdt([H|Tail], Max, Index) :-
    max_f(Tail, TempMax, TempIndex),
    (H > TempMax -> (Max = H, Index = 0); (Max = TempMax, Index is TempIndex + 1)).

max_f_without_stdrd_prdt([], -9999, -1).
```
С встроенными предикатами:
```prolog
max_f(List, Max, Index) :-
    nth0(Index, List, Max),   % Находим индекс максимального элемента
    max_list(List, Max).

```
nth0 поиск индекса максимального элемента, max_list - поиск максимального элемента.
## Задание 1.3: Предикат(для содержательного примера)
`find_perm_shortened_arr(List,Perm)` - Создаётся усеченный список до Index(Max), а далее выводится все перестановки такого списка Perm.
Примеры использования:
```prolog
?- find_perm_shortened_arr([1,2,6,4,5],Perm).
Perm = [1, 2] ;
Perm = [2, 1] ;
false.
```

Реализация:
Находим индекс максимального элемента, производим усечение изначального массива до Index, и выводим все перестановки такого массива.
```prolog
find_perm_shortened_arr(List,Perm) :- % Получаем список до Max, и находим все перестановки такого списка.
    max_f_without_stdrd_prdt(List,_,Index),
    func4(List,Index,TruncatedList),
    permute_f(TruncatedList,Perm).

```
## Задание 2: Реляционное представление данных

Реляционное программирование фокусируется на описании отношений между аргументами и результатами, и оно строится на понятии отношений между объектами. Это подход, в котором программисты описывают отношения между данными вместо императивных последовательных инструкций. Основной целью в реляционном программировании является создание программ, способных анализировать и извлекать информацию из этих отношений.

Реляционное программирование обладает несколькими преимуществами, такими как теоретическая основанность и независимость данных. Однако, у этого подхода могут быть и недостатки, такие как более низкая производительность при выполнении операций соединения данных. В случае небольших таблиц с данными, такие как таблицы с оценками студентов, компактность может быть положительным аспектом и ускорить определенные запросы к базе данных. Однако, навигация и поиск в таких таблицах может быть менее удобным из-за необходимости перебирать студентов и их оценки при выполнении запросов.

Задание 2.1:

Запуск программы:
```prolog
?- print_all.

```
Результат работы программы(Файл two.pl):
```prolog
?- print_all.
The average score of the group 101: 4.033333333333333
The average score of the group 102: 3.7037037037037037
The average score of the group 103: 4.020833333333333
The average score of the group 104: 3.9444444444444446

The subject that passed for 2 Психология, Surnames: [Ивановский]
The subject that passed for 2 Логическое программирование, Surnames: [Сидоров,Блокчейнис]
The subject that passed for 2 Математический анализ, Surnames: [Петров,Петровский,Сиплюсплюсов]
The subject that passed for 2 Функциональное программирование, Surnames: [Эфиркина]
The subject that passed for 2 Информатика, Surnames: [Сиплюсплюсов,Текстописов]
The subject that passed for 2 Английский язык, Surnames: [Круглосчиталкин,Эксель,Текстописова,Круглотличников]

The number of people who passed for 2 in the group 101: 2
The number of people who passed for 2 in the group 102: 5
The number of people who passed for 2 in the group 103: 4
The number of people who passed for 2 in the group 104: 2
true.
```
```prolog

```
Теперь разберём части кода:
```prolog
print_all:-
    Groups = [101, 102, 103, 104], % Список групп
    Subjects = ['Психология','Логическое программирование','Математический анализ','Функциональное программирование','Информатика','Английский язык'],
    print_group_averages(Groups),
    nl,
    print_subject_grade2(Subjects),
    nl,
    print_count_grade2(Groups).
% _______________________________________________________________________________________
```
print_all Формирует вывод.

print_group_averages(Groups). Задание 2.1
print_subject_grade2(Subjects). Задание 2.2
printf_count_grade2(Groups). Задание 2.3
Правила.

Реализация правил.
```prolog
print_group_averages([]).
print_group_averages([Group | Rest]) :-
    print_group_average(Group),
    print_group_averages(Rest).
print_subject_grade2([]).
print_subject_grade2([Subject | Rest]) :-
    print_grade2(Subject),
    print_subject_grade2(Rest).
print_count_grade2([]).
print_count_grade2([Subject | Rest]) :-
    print_count(Subject),
    print_count_grade2(Rest).
```
Обработка ввода по правилам.
```prolog
print_group_average(Group) :-
    findall(Rating, grade(Group, _, _, Rating), Ratings),
    average(Ratings, Avg),
    format('The average score of the group ~w: ~w~n', [Group, Avg]).

print_grade2(Subject) :-
    findall(Surname,grade(_,Surname,Subject,2),Surname),
    format('The subject that passed for 2 ~w, Surnames: ~w~n', [Subject, Surname]).

print_count(Group) :-
    findall(Surname,grade(Group,Surname,_,2), Surnames),
    length(Surnames,Length),
    format('The number of people who passed for 2 in the group ~w: ~w~n',[Group,Length]).
% ________________________________________________________________________________________
```
Ну и ещё использовался предикат для вычисления средних значений:
```prolog
average([], 0).
average(List, Avg) :-
    sum_list(List, Sum),
    length(List, Count),
    Avg is Sum / Count.
```
## Выводы

Пролог - это язык логического программирования, который обладает несколькими особенностями, делающими его уникальным и интересным. Одно из преимуществ, которое я выделил, является простота чтения программ, так как в языке используется небольшое количество специальных символов и ключевых слов, и программы легко переводятся на естественный язык.

Программы на Пролог состоят из двух основных элементов: предикатов и объектов. Предикаты представляют условия, которые принимают входные параметры. Например, "length([],Num)" или "max([],Num,Num)". Объектами могут быть термы, константы (числа и строки) и переменные, которые представляют неизвестные объекты.

Пролог существенно отличается от традиционных процедурных языков программирования как в организации вычислений, так и в представлении данных. Он использует логический подход к программированию и строит вычисления на основе логических отношений между объектами.

Изучение Пролога может потребовать времени и усилий, но трассировка (отслеживание выполнения программы) может помочь лучше понять, как язык Пролог решает задачи и как работает механизм бэктрекинга. Пролог оказывается мощным средством для решения разнообразных задач, и более глубокое изучение его механизмов может открыть новые возможности для программирования и решения задач.




